
simple.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000564  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000054e  00800060  00000564  000005f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  008005ae  008005ae  00000b46  2**0
                  ALLOC
  3 .stab         00000540  00000000  00000000  00000b48  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000024  00000000  00000000  00001088  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000040  00000000  00000000  000010ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000094  00000000  00000000  000010ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000475  00000000  00000000  00001180  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000001ba  00000000  00000000  000015f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000575  00000000  00000000  000017af  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000070  00000000  00000000  00001d24  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000000d7  00000000  00000000  00001d94  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000142  00000000  00000000  00001e6b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000a8  00000000  00000000  00001fad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	15 e0       	ldi	r17, 0x05	; 5
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e6       	ldi	r30, 0x64	; 100
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	ae 3a       	cpi	r26, 0xAE	; 174
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	15 e0       	ldi	r17, 0x05	; 5
  78:	ae ea       	ldi	r26, 0xAE	; 174
  7a:	b5 e0       	ldi	r27, 0x05	; 5
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 3b       	cpi	r26, 0xB0	; 176
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 49 00 	call	0x92	; 0x92 <main>
  8a:	0c 94 b0 02 	jmp	0x560	; 0x560 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
#include "disp.h"
#include "lcd.h"


int main(void)
{
  92:	ef 92       	push	r14
  94:	ff 92       	push	r15
  96:	1f 93       	push	r17
  98:	df 93       	push	r29
  9a:	cf 93       	push	r28
  9c:	cd b7       	in	r28, 0x3d	; 61
  9e:	de b7       	in	r29, 0x3e	; 62
  a0:	2c 97       	sbiw	r28, 0x0c	; 12
  a2:	0f b6       	in	r0, 0x3f	; 63
  a4:	f8 94       	cli
  a6:	de bf       	out	0x3e, r29	; 62
  a8:	0f be       	out	0x3f, r0	; 63
  aa:	cd bf       	out	0x3d, r28	; 61
  uint8_t i;
  char txt[]={'H','e','l','l','o',' ','W','o','r','l','d',0};
  ac:	7e 01       	movw	r14, r28
  ae:	08 94       	sec
  b0:	e1 1c       	adc	r14, r1
  b2:	f1 1c       	adc	r15, r1
  b4:	d7 01       	movw	r26, r14
  b6:	e0 e6       	ldi	r30, 0x60	; 96
  b8:	f0 e0       	ldi	r31, 0x00	; 0
  ba:	8c e0       	ldi	r24, 0x0C	; 12
  bc:	01 90       	ld	r0, Z+
  be:	0d 92       	st	X+, r0
  c0:	81 50       	subi	r24, 0x01	; 1
  c2:	e1 f7       	brne	.-8      	; 0xbc <main+0x2a>

  /* INITIALIZE */
  lcd_init();
  c4:	0e 94 43 02 	call	0x486	; 0x486 <lcd_init>
  backcolor=0xA000;
  c8:	80 e0       	ldi	r24, 0x00	; 0
  ca:	90 ea       	ldi	r25, 0xA0	; 160
  cc:	90 93 ad 05 	sts	0x05AD, r25
  d0:	80 93 ac 05 	sts	0x05AC, r24
  textcolor=0xFFFF;
  d4:	8f ef       	ldi	r24, 0xFF	; 255
  d6:	9f ef       	ldi	r25, 0xFF	; 255
  d8:	90 93 af 05 	sts	0x05AF, r25
  dc:	80 93 ae 05 	sts	0x05AE, r24
  fill_screen(backcolor);
  e0:	80 e0       	ldi	r24, 0x00	; 0
  e2:	90 ea       	ldi	r25, 0xA0	; 160
  e4:	0e 94 a3 00 	call	0x146	; 0x146 <fill_screen>
   
  i=0;
  while (txt[i]!=0)
  e8:	49 81       	ldd	r20, Y+1	; 0x01
  ea:	44 23       	and	r20, r20
  ec:	b9 f0       	breq	.+46     	; 0x11c <main+0x8a>
  ee:	10 e0       	ldi	r17, 0x00	; 0
  f0:	80 e0       	ldi	r24, 0x00	; 0
  f2:	90 e0       	ldi	r25, 0x00	; 0
  {
    // two possible text outputs, same lower left (0) upper left (90) corner pixel
//    put_char(10+i*CHAR_W,60,txt[i],1);  // 90 deg. rotated
    put_char(45+i*CHAR_W,60,txt[i],0);   // 0 deg. rotated
  f4:	88 0f       	add	r24, r24
  f6:	99 1f       	adc	r25, r25
  f8:	88 0f       	add	r24, r24
  fa:	99 1f       	adc	r25, r25
  fc:	88 0f       	add	r24, r24
  fe:	99 1f       	adc	r25, r25
 100:	83 5d       	subi	r24, 0xD3	; 211
 102:	6c e3       	ldi	r22, 0x3C	; 60
 104:	20 e0       	ldi	r18, 0x00	; 0
 106:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <put_char>
    i++;
 10a:	1f 5f       	subi	r17, 0xFF	; 255
  backcolor=0xA000;
  textcolor=0xFFFF;
  fill_screen(backcolor);
   
  i=0;
  while (txt[i]!=0)
 10c:	81 2f       	mov	r24, r17
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	f7 01       	movw	r30, r14
 112:	e8 0f       	add	r30, r24
 114:	f9 1f       	adc	r31, r25
 116:	40 81       	ld	r20, Z
 118:	44 23       	and	r20, r20
 11a:	61 f7       	brne	.-40     	; 0xf4 <main+0x62>
 11c:	ff cf       	rjmp	.-2      	; 0x11c <main+0x8a>

0000011e <lcd_wrdat16>:
  lcd_wrcmd((dat>>8));
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
 11e:	1f 93       	push	r17
 120:	18 2f       	mov	r17, r24
  lcd_wrdata(dat>>8);
 122:	89 2f       	mov	r24, r25
 124:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 128:	81 2f       	mov	r24, r17
 12a:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
}
 12e:	1f 91       	pop	r17
 130:	08 95       	ret

00000132 <lcd_wrcmd16>:
uint16_t backcolor=0xFFFF;    // color of background
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
 132:	1f 93       	push	r17
 134:	18 2f       	mov	r17, r24
  lcd_wrcmd((dat>>8));
 136:	89 2f       	mov	r24, r25
 138:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 13c:	81 2f       	mov	r24, r17
 13e:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
}
 142:	1f 91       	pop	r17
 144:	08 95       	ret

00000146 <fill_screen>:
  lcd_wrdata(dat>>8);
  lcd_wrdata(dat);
}

void fill_screen(uint16_t color)
{
 146:	0f 93       	push	r16
 148:	1f 93       	push	r17
 14a:	cf 93       	push	r28
 14c:	df 93       	push	r29
 14e:	8c 01       	movw	r16, r24
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 150:	8f ee       	ldi	r24, 0xEF	; 239
 152:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 156:	80 e9       	ldi	r24, 0x90	; 144
 158:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 15c:	85 e0       	ldi	r24, 0x05	; 5
 15e:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 162:	80 e0       	ldi	r24, 0x00	; 0
 164:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 168:	86 e0       	ldi	r24, 0x06	; 6
 16a:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 16e:	80 e0       	ldi	r24, 0x00	; 0
 170:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 174:	87 e0       	ldi	r24, 0x07	; 7
 176:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
 180:	c0 e0       	ldi	r28, 0x00	; 0
 182:	d0 e0       	ldi	r29, 0x00	; 0
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 184:	81 2f       	mov	r24, r17
 186:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 18a:	80 2f       	mov	r24, r16
 18c:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
 190:	21 96       	adiw	r28, 0x01	; 1
  lcd_wrcmd16(0xEF90);
  lcd_wrcmd16(0x0500);
  lcd_wrcmd16(0x0600);
  lcd_wrcmd16(0x0700);
    
  for (i=0; i<DISP_W*DISP_H; i++)
 192:	8a e5       	ldi	r24, 0x5A	; 90
 194:	c0 3c       	cpi	r28, 0xC0	; 192
 196:	d8 07       	cpc	r29, r24
 198:	a9 f7       	brne	.-22     	; 0x184 <fill_screen+0x3e>
    lcd_wrdat16(color);
}
 19a:	df 91       	pop	r29
 19c:	cf 91       	pop	r28
 19e:	1f 91       	pop	r17
 1a0:	0f 91       	pop	r16
 1a2:	08 95       	ret

000001a4 <put_char>:

void put_char(uint8_t x, uint8_t y, char c, uint8_t rot)
{
 1a4:	cf 92       	push	r12
 1a6:	df 92       	push	r13
 1a8:	ef 92       	push	r14
 1aa:	ff 92       	push	r15
 1ac:	0f 93       	push	r16
 1ae:	1f 93       	push	r17
 1b0:	cf 93       	push	r28
 1b2:	df 93       	push	r29
 1b4:	e8 2e       	mov	r14, r24
 1b6:	f6 2e       	mov	r15, r22
 1b8:	d4 2e       	mov	r13, r20
 1ba:	c2 2e       	mov	r12, r18
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 1bc:	8f ee       	ldi	r24, 0xEF	; 239
 1be:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 1c2:	80 e9       	ldi	r24, 0x90	; 144
 1c4:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
{
  uint8_t h,ch,p,mask;

  lcd_wrcmd16(0xEF90);

  if (rot)
 1c8:	cc 20       	and	r12, r12
 1ca:	09 f4       	brne	.+2      	; 0x1ce <put_char+0x2a>
 1cc:	12 c1       	rjmp	.+548    	; 0x3f2 <put_char+0x24e>
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 1ce:	85 e0       	ldi	r24, 0x05	; 5
 1d0:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 1d4:	80 e0       	ldi	r24, 0x00	; 0
 1d6:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd16(0xEF90);

  if (rot)
  {
    lcd_wrcmd16(0x0500);
    lcd_wrcmd16(0x0800+x);
 1da:	0e 2d       	mov	r16, r14
 1dc:	10 e0       	ldi	r17, 0x00	; 0
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 1de:	88 e0       	ldi	r24, 0x08	; 8
 1e0:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 1e4:	8e 2d       	mov	r24, r14
 1e6:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>

  if (rot)
  {
    lcd_wrcmd16(0x0500);
    lcd_wrcmd16(0x0800+x);
    lcd_wrcmd16(0x0A00+y);
 1ea:	ef 2c       	mov	r14, r15
 1ec:	ff 24       	eor	r15, r15
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 1ee:	8a e0       	ldi	r24, 0x0A	; 10
 1f0:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 1f4:	8e 2d       	mov	r24, r14
 1f6:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  if (rot)
  {
    lcd_wrcmd16(0x0500);
    lcd_wrcmd16(0x0800+x);
    lcd_wrcmd16(0x0A00+y);
    lcd_wrcmd16(0x0900+x+CHAR_W-1);
 1fa:	09 5f       	subi	r16, 0xF9	; 249
 1fc:	16 4f       	sbci	r17, 0xF6	; 246
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 1fe:	81 2f       	mov	r24, r17
 200:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 204:	80 2f       	mov	r24, r16
 206:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  {
    lcd_wrcmd16(0x0500);
    lcd_wrcmd16(0x0800+x);
    lcd_wrcmd16(0x0A00+y);
    lcd_wrcmd16(0x0900+x+CHAR_W-1);
    lcd_wrcmd16(0x0B00+y+CHAR_H-1);
 20a:	8d e0       	ldi	r24, 0x0D	; 13
 20c:	9b e0       	ldi	r25, 0x0B	; 11
 20e:	e8 0e       	add	r14, r24
 210:	f9 1e       	adc	r15, r25
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 212:	8f 2d       	mov	r24, r15
 214:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 218:	8e 2d       	mov	r24, r14
 21a:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  }
  
  for (h=0; h<CHAR_H; h++) // every column of the character
  {
        if (rot)
          ch=ascii_tab[ c-32 ][h];	
 21e:	8d 2d       	mov	r24, r13
 220:	90 e0       	ldi	r25, 0x00	; 0
 222:	80 97       	sbiw	r24, 0x20	; 32
 224:	88 0f       	add	r24, r24
 226:	99 1f       	adc	r25, r25
 228:	9c 01       	movw	r18, r24
 22a:	22 0f       	add	r18, r18
 22c:	33 1f       	adc	r19, r19
 22e:	22 0f       	add	r18, r18
 230:	33 1f       	adc	r19, r19
 232:	22 0f       	add	r18, r18
 234:	33 1f       	adc	r19, r19
 236:	28 1b       	sub	r18, r24
 238:	39 0b       	sbc	r19, r25
 23a:	8c e6       	ldi	r24, 0x6C	; 108
 23c:	e8 2e       	mov	r14, r24
 23e:	80 e0       	ldi	r24, 0x00	; 0
 240:	f8 2e       	mov	r15, r24
 242:	e2 0e       	add	r14, r18
 244:	f3 1e       	adc	r15, r19
 246:	e9 01       	movw	r28, r18
 248:	c7 58       	subi	r28, 0x87	; 135
 24a:	df 4f       	sbci	r29, 0xFF	; 255
 24c:	dd 24       	eor	r13, r13
 24e:	63 c0       	rjmp	.+198    	; 0x316 <put_char+0x172>
 250:	f7 01       	movw	r30, r14
 252:	00 81       	ld	r16, Z
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 254:	07 fd       	sbrc	r16, 7
 256:	65 c0       	rjmp	.+202    	; 0x322 <put_char+0x17e>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 258:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 25c:	80 91 ad 05 	lds	r24, 0x05AD
 260:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 264:	81 2f       	mov	r24, r17
 266:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 26a:	06 fd       	sbrc	r16, 6
 26c:	65 c0       	rjmp	.+202    	; 0x338 <put_char+0x194>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 26e:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 272:	80 91 ad 05 	lds	r24, 0x05AD
 276:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 27a:	81 2f       	mov	r24, r17
 27c:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 280:	05 fd       	sbrc	r16, 5
 282:	65 c0       	rjmp	.+202    	; 0x34e <put_char+0x1aa>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 284:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 288:	80 91 ad 05 	lds	r24, 0x05AD
 28c:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 290:	81 2f       	mov	r24, r17
 292:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 296:	04 fd       	sbrc	r16, 4
 298:	65 c0       	rjmp	.+202    	; 0x364 <put_char+0x1c0>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 29a:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 29e:	80 91 ad 05 	lds	r24, 0x05AD
 2a2:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 2a6:	81 2f       	mov	r24, r17
 2a8:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 2ac:	03 fd       	sbrc	r16, 3
 2ae:	65 c0       	rjmp	.+202    	; 0x37a <put_char+0x1d6>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 2b0:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 2b4:	80 91 ad 05 	lds	r24, 0x05AD
 2b8:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 2bc:	81 2f       	mov	r24, r17
 2be:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 2c2:	02 fd       	sbrc	r16, 2
 2c4:	65 c0       	rjmp	.+202    	; 0x390 <put_char+0x1ec>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 2c6:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 2ca:	80 91 ad 05 	lds	r24, 0x05AD
 2ce:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 2d2:	81 2f       	mov	r24, r17
 2d4:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 2d8:	01 fd       	sbrc	r16, 1
 2da:	65 c0       	rjmp	.+202    	; 0x3a6 <put_char+0x202>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 2dc:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 2e0:	80 91 ad 05 	lds	r24, 0x05AD
 2e4:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 2e8:	81 2f       	mov	r24, r17
 2ea:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 2ee:	00 ff       	sbrs	r16, 0
 2f0:	65 c0       	rjmp	.+202    	; 0x3bc <put_char+0x218>
          {
            lcd_wrdat16(textcolor);                
 2f2:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 2f6:	80 91 af 05 	lds	r24, 0x05AF
 2fa:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 2fe:	81 2f       	mov	r24, r17
 300:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
    lcd_wrcmd16(0x0A00+x);
    lcd_wrcmd16(0x0900+y+CHAR_H-1);
    lcd_wrcmd16(0x0B00+x+CHAR_W-1);
  }
  
  for (h=0; h<CHAR_H; h++) // every column of the character
 304:	d3 94       	inc	r13
 306:	08 94       	sec
 308:	e1 1c       	adc	r14, r1
 30a:	f1 1c       	adc	r15, r1
 30c:	21 97       	sbiw	r28, 0x01	; 1
 30e:	fe e0       	ldi	r31, 0x0E	; 14
 310:	df 16       	cp	r13, r31
 312:	09 f4       	brne	.+2      	; 0x316 <put_char+0x172>
 314:	65 c0       	rjmp	.+202    	; 0x3e0 <put_char+0x23c>
  {
        if (rot)
 316:	cc 20       	and	r12, r12
 318:	09 f0       	breq	.+2      	; 0x31c <put_char+0x178>
 31a:	9a cf       	rjmp	.-204    	; 0x250 <put_char+0xac>
          ch=ascii_tab[ c-32 ][h];	
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
 31c:	08 81       	ld	r16, Y
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 31e:	07 ff       	sbrs	r16, 7
 320:	9b cf       	rjmp	.-202    	; 0x258 <put_char+0xb4>
          {
            lcd_wrdat16(textcolor);                
 322:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 326:	80 91 af 05 	lds	r24, 0x05AF
 32a:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 32e:	81 2f       	mov	r24, r17
 330:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 334:	06 ff       	sbrs	r16, 6
 336:	9b cf       	rjmp	.-202    	; 0x26e <put_char+0xca>
          {
            lcd_wrdat16(textcolor);                
 338:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 33c:	80 91 af 05 	lds	r24, 0x05AF
 340:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 344:	81 2f       	mov	r24, r17
 346:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 34a:	05 ff       	sbrs	r16, 5
 34c:	9b cf       	rjmp	.-202    	; 0x284 <put_char+0xe0>
          {
            lcd_wrdat16(textcolor);                
 34e:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 352:	80 91 af 05 	lds	r24, 0x05AF
 356:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 35a:	81 2f       	mov	r24, r17
 35c:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 360:	04 ff       	sbrs	r16, 4
 362:	9b cf       	rjmp	.-202    	; 0x29a <put_char+0xf6>
          {
            lcd_wrdat16(textcolor);                
 364:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 368:	80 91 af 05 	lds	r24, 0x05AF
 36c:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 370:	81 2f       	mov	r24, r17
 372:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 376:	03 ff       	sbrs	r16, 3
 378:	9b cf       	rjmp	.-202    	; 0x2b0 <put_char+0x10c>
          {
            lcd_wrdat16(textcolor);                
 37a:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 37e:	80 91 af 05 	lds	r24, 0x05AF
 382:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 386:	81 2f       	mov	r24, r17
 388:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 38c:	02 ff       	sbrs	r16, 2
 38e:	9b cf       	rjmp	.-202    	; 0x2c6 <put_char+0x122>
          {
            lcd_wrdat16(textcolor);                
 390:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 394:	80 91 af 05 	lds	r24, 0x05AF
 398:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 39c:	81 2f       	mov	r24, r17
 39e:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 3a2:	01 ff       	sbrs	r16, 1
 3a4:	9b cf       	rjmp	.-202    	; 0x2dc <put_char+0x138>
          {
            lcd_wrdat16(textcolor);                
 3a6:	10 91 ae 05 	lds	r17, 0x05AE
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 3aa:	80 91 af 05 	lds	r24, 0x05AF
 3ae:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 3b2:	81 2f       	mov	r24, r17
 3b4:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
	else
          ch=ascii_tab[ c-32 ][CHAR_H-h-1];
        mask=0x80;
        for (p=0; p<CHAR_W; p++)  // write the pixels
        {
          if (ch&mask)
 3b8:	00 fd       	sbrc	r16, 0
 3ba:	9b cf       	rjmp	.-202    	; 0x2f2 <put_char+0x14e>
          {
            lcd_wrdat16(textcolor);                
          }
          else
          {
            lcd_wrdat16(backcolor);
 3bc:	10 91 ac 05 	lds	r17, 0x05AC
  lcd_wrcmd(dat);
}

void lcd_wrdat16(uint16_t dat)
{
  lcd_wrdata(dat>>8);
 3c0:	80 91 ad 05 	lds	r24, 0x05AD
 3c4:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
  lcd_wrdata(dat);
 3c8:	81 2f       	mov	r24, r17
 3ca:	0e 94 86 02 	call	0x50c	; 0x50c <lcd_wrdata>
    lcd_wrcmd16(0x0A00+x);
    lcd_wrcmd16(0x0900+y+CHAR_H-1);
    lcd_wrcmd16(0x0B00+x+CHAR_W-1);
  }
  
  for (h=0; h<CHAR_H; h++) // every column of the character
 3ce:	d3 94       	inc	r13
 3d0:	08 94       	sec
 3d2:	e1 1c       	adc	r14, r1
 3d4:	f1 1c       	adc	r15, r1
 3d6:	21 97       	sbiw	r28, 0x01	; 1
 3d8:	fe e0       	ldi	r31, 0x0E	; 14
 3da:	df 16       	cp	r13, r31
 3dc:	09 f0       	breq	.+2      	; 0x3e0 <put_char+0x23c>
 3de:	9b cf       	rjmp	.-202    	; 0x316 <put_char+0x172>
            lcd_wrdat16(backcolor);
          }
          mask=mask/2;
        }  // for p
  }
}
 3e0:	df 91       	pop	r29
 3e2:	cf 91       	pop	r28
 3e4:	1f 91       	pop	r17
 3e6:	0f 91       	pop	r16
 3e8:	ff 90       	pop	r15
 3ea:	ef 90       	pop	r14
 3ec:	df 90       	pop	r13
 3ee:	cf 90       	pop	r12
 3f0:	08 95       	ret
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 3f2:	85 e0       	ldi	r24, 0x05	; 5
 3f4:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 3f8:	84 e0       	ldi	r24, 0x04	; 4
 3fa:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
    lcd_wrcmd16(0x0B00+y+CHAR_H-1);
  }
  else
  {
    lcd_wrcmd16(0x0504);
    lcd_wrcmd16(0x0800+y);
 3fe:	0f 2d       	mov	r16, r15
 400:	10 e0       	ldi	r17, 0x00	; 0
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 402:	88 e0       	ldi	r24, 0x08	; 8
 404:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 408:	8f 2d       	mov	r24, r15
 40a:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  }
  else
  {
    lcd_wrcmd16(0x0504);
    lcd_wrcmd16(0x0800+y);
    lcd_wrcmd16(0x0A00+x);
 40e:	ff 24       	eor	r15, r15
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 410:	8a e0       	ldi	r24, 0x0A	; 10
 412:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 416:	8e 2d       	mov	r24, r14
 418:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  else
  {
    lcd_wrcmd16(0x0504);
    lcd_wrcmd16(0x0800+y);
    lcd_wrcmd16(0x0A00+x);
    lcd_wrcmd16(0x0900+y+CHAR_H-1);
 41c:	03 5f       	subi	r16, 0xF3	; 243
 41e:	16 4f       	sbci	r17, 0xF6	; 246
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 420:	81 2f       	mov	r24, r17
 422:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 426:	80 2f       	mov	r24, r16
 428:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  {
    lcd_wrcmd16(0x0504);
    lcd_wrcmd16(0x0800+y);
    lcd_wrcmd16(0x0A00+x);
    lcd_wrcmd16(0x0900+y+CHAR_H-1);
    lcd_wrcmd16(0x0B00+x+CHAR_W-1);
 42c:	e7 e0       	ldi	r30, 0x07	; 7
 42e:	fb e0       	ldi	r31, 0x0B	; 11
 430:	ee 0e       	add	r14, r30
 432:	ff 1e       	adc	r15, r31
uint16_t textcolor=0x0000;


void lcd_wrcmd16(uint16_t dat)
{
  lcd_wrcmd((dat>>8));
 434:	8f 2d       	mov	r24, r15
 436:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
  lcd_wrcmd(dat);
 43a:	8e 2d       	mov	r24, r14
 43c:	0e 94 83 02 	call	0x506	; 0x506 <lcd_wrcmd>
 440:	ee ce       	rjmp	.-548    	; 0x21e <put_char+0x7a>

00000442 <mswait>:
// void mswait(uint16_t ms);           
// wait some milliseconds, XTAL must be correct defined

        .global glcdWait                // used T0,T1 stack 0
mswait:
        sbiw    r24, 1                                   // 2
 442:	01 97       	sbiw	r24, 0x01	; 1
        brcc    mswait1                               // 2
 444:	08 f4       	brcc	.+2      	; 0x448 <mswait1>
        ret                                             // 2 -2 = 0 for no branch in both loops
 446:	08 95       	ret

00000448 <mswait1>:
mswait1:
        nop
 448:	00 00       	nop
        ldi     r26, lo8(DELAY_ONE_MILLISECOND -4)       // 1
 44a:	ac e9       	ldi	r26, 0x9C	; 156
        ldi     r27, hi8(DELAY_ONE_MILLISECOND -4)       // 1
 44c:	bf e0       	ldi	r27, 0x0F	; 15

0000044e <mswait2>:
mswait2:
        sbiw    r26, 1                                   // 2
 44e:	11 97       	sbiw	r26, 0x01	; 1
        brne    mswait2                               // 2 = 4, = 3 for last loop
 450:	f1 f7       	brne	.-4      	; 0x44e <mswait2>
        rjmp    mswait                                // 2 = 8
 452:	f7 cf       	rjmp	.-18     	; 0x442 <mswait>

00000454 <port_init_io>:
;void port_init_io(void)
    .global port_init_io
port_init_io:
    ; setup serial data I/O pins

    cbi     PORTB, LCD_RESET        ; display reset
 454:	c2 98       	cbi	0x18, 2	; 24
    sbi     DDRB, LCD_RESET         ; set reset as output
 456:	ba 9a       	sbi	0x17, 2	; 23
;   sbi     DDRB, LCD_MISO          ; MISO is always input in SPI
    sbi     DDRB, LCD_MOSI          ; MOSI must be set as output for SPI
 458:	b9 9a       	sbi	0x17, 1	; 23
    sbi         PORTB, LCD_CS           ; deselect display 
 45a:	c3 9a       	sbi	0x18, 3	; 24
    sbi     DDRB, LCD_CS            ; SS must be output for Master mode to work
 45c:	bb 9a       	sbi	0x17, 3	; 23


    cbi     PORTB, LCD_SCK          ; set SCK lo
 45e:	c4 98       	cbi	0x18, 4	; 24
    sbi     DDRB,  LCD_SCK          ; set SCK as output
 460:	bc 9a       	sbi	0x17, 4	; 23
    sbi     PORTB, LCD_MISO         ; enable pull up of MISO to avoid floating input
 462:	c5 9a       	sbi	0x18, 5	; 24

    sbi     PORTB, LCD_RS           ; start with RS=high
 464:	c0 9a       	sbi	0x18, 0	; 24
    sbi     DDRB, LCD_RS            ; RS signal is output
 466:	b8 9a       	sbi	0x17, 0	; 23
    ; select clock phase positive going in middle of data
    ; master mode
    ; enable SPI
    ; speed is CPUclock/2

    ldi     r24,(1<<MSTR) | (1<<SPE); | (1<<SPR0);  ; Master Mode,  Enable SPI, fCPU/16 clock
 468:	80 e5       	ldi	r24, 0x50	; 80
    out     SPCR,r24
 46a:	8d b9       	out	0x0d, r24	; 13

    ldi     r24,1           ; double speed bit
 46c:	81 e0       	ldi	r24, 0x01	; 1
    out     SPSR,r24
 46e:	8e b9       	out	0x0e, r24	; 14

    ldi     r24,1
 470:	81 e0       	ldi	r24, 0x01	; 1
    ldi     r25,0
 472:	90 e0       	ldi	r25, 0x00	; 0
    rcall   mswait          ; wait one ms to have a nice reset
 474:	e6 df       	rcall	.-52     	; 0x442 <mswait>
    sbi     PORTB, LCD_RESET    ; release reset
 476:	c2 9a       	sbi	0x18, 2	; 24
    in      r24,SPSR        ; clear status
 478:	8e b1       	in	r24, 0x0e	; 14
    ret
 47a:	08 95       	ret

0000047c <wrtab>:

;************************************************
; write table with r30/r31 pointer to table
; r22 number of bytes to read
wrtab:
    lpm     r24,Z+          ; load byte from table
 47c:	85 91       	lpm	r24, Z+
    rcall   lcd_wrcmd
 47e:	43 d0       	rcall	.+134    	; 0x506 <lcd_wrcmd>
    dec     r22
 480:	6a 95       	dec	r22
    brne    wrtab
 482:	e1 f7       	brne	.-8      	; 0x47c <wrtab>
    ret
 484:	08 95       	ret

00000486 <lcd_init>:
;        r22/r24
;void lcd_init(void)
    .global lcd_init

lcd_init:
    push    r30
 486:	ef 93       	push	r30
    push    r31
 488:	ff 93       	push	r31

    sbi     PORTB,LCD_CS    ;deselect Display
 48a:	c3 9a       	sbi	0x18, 3	; 24
    sbi     DDRB,LCD_CS     ;
 48c:	bb 9a       	sbi	0x17, 3	; 23
    call    port_init_io    ;init SPI
 48e:	0e 94 2a 02 	call	0x454	; 0x454 <port_init_io>
    
    ldi     r30,lo8(INIT1)  ;set pointer to table
 492:	ee e1       	ldi	r30, 0x1E	; 30
    ldi     r31,hi8(INIT1)       
 494:	f5 e0       	ldi	r31, 0x05	; 5
    ldi     r22,24      ;number of bytes to be transmitted
 496:	68 e1       	ldi	r22, 0x18	; 24
    rcall   wrtab
 498:	f1 df       	rcall	.-30     	; 0x47c <wrtab>
        
    ; wait for settling
    ldi     r24,7
 49a:	87 e0       	ldi	r24, 0x07	; 7
    ldi     r25,0
 49c:	90 e0       	ldi	r25, 0x00	; 0
    rcall   mswait
 49e:	d1 df       	rcall	.-94     	; 0x442 <mswait>

    ldi     r30,lo8(INIT2)  ;set pointer to table
 4a0:	e6 e3       	ldi	r30, 0x36	; 54
    ldi     r31,hi8(INIT2)       
 4a2:	f5 e0       	ldi	r31, 0x05	; 5
    ldi     r22,40          ;number of bytes to be transmitted
 4a4:	68 e2       	ldi	r22, 0x28	; 40
    rcall   wrtab
 4a6:	ea df       	rcall	.-44     	; 0x47c <wrtab>

    ; wait for settling
    ldi     r24,50
 4a8:	82 e3       	ldi	r24, 0x32	; 50
    ldi     r25,0
 4aa:	90 e0       	ldi	r25, 0x00	; 0
    rcall   mswait
 4ac:	ca df       	rcall	.-108    	; 0x442 <mswait>

    ldi     r30,lo8(INIT3)  ;set pointer to table
 4ae:	ee e5       	ldi	r30, 0x5E	; 94
    ldi     r31,hi8(INIT3)       
 4b0:	f5 e0       	ldi	r31, 0x05	; 5
    ldi     r22,2          ;number of bytes to be transmitted
 4b2:	62 e0       	ldi	r22, 0x02	; 2
    rcall   wrtab
 4b4:	e3 df       	rcall	.-58     	; 0x47c <wrtab>


    ;   write initial screen command
    cbi     PORTB,LCD_CS    ;select Display
 4b6:	c3 98       	cbi	0x18, 3	; 24

    ldi     r24,0xEF
 4b8:	8f ee       	ldi	r24, 0xEF	; 239
    rcall   lcd_wrcmd
 4ba:	25 d0       	rcall	.+74     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x90
 4bc:	80 e9       	ldi	r24, 0x90	; 144
    rcall   lcd_wrcmd
 4be:	23 d0       	rcall	.+70     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x00
 4c0:	80 e0       	ldi	r24, 0x00	; 0
    rcall   lcd_wrcmd
 4c2:	21 d0       	rcall	.+66     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x00
 4c4:	80 e0       	ldi	r24, 0x00	; 0
    rcall   lcd_wrcmd
 4c6:	1f d0       	rcall	.+62     	; 0x506 <lcd_wrcmd>

    rcall   lcd_clrscr
 4c8:	03 d0       	rcall	.+6      	; 0x4d0 <lcd_clrscr>

    pop     r31
 4ca:	ff 91       	pop	r31
    pop     r30
 4cc:	ef 91       	pop	r30
    ret
 4ce:	08 95       	ret

000004d0 <lcd_clrscr>:
;clear LCD
;        r24
;void lcd_clrscr(void)
    .global lcd_clrscr
lcd_clrscr:
    push    r30
 4d0:	ef 93       	push	r30
    push    r31
 4d2:	ff 93       	push	r31

    ; send window write start sequence
    ldi     r24,0xEF
 4d4:	8f ee       	ldi	r24, 0xEF	; 239
    rcall   lcd_wrcmd
 4d6:	17 d0       	rcall	.+46     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x90
 4d8:	80 e9       	ldi	r24, 0x90	; 144
    rcall   lcd_wrcmd
 4da:	15 d0       	rcall	.+42     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x05
 4dc:	85 e0       	ldi	r24, 0x05	; 5
    rcall   lcd_wrcmd
 4de:	13 d0       	rcall	.+38     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x00
 4e0:	80 e0       	ldi	r24, 0x00	; 0
    rcall   lcd_wrcmd
 4e2:	11 d0       	rcall	.+34     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x06
 4e4:	86 e0       	ldi	r24, 0x06	; 6
    rcall   lcd_wrcmd
 4e6:	0f d0       	rcall	.+30     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x00
 4e8:	80 e0       	ldi	r24, 0x00	; 0
    rcall   lcd_wrcmd
 4ea:	0d d0       	rcall	.+26     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x07
 4ec:	87 e0       	ldi	r24, 0x07	; 7
    rcall   lcd_wrcmd
 4ee:	0b d0       	rcall	.+22     	; 0x506 <lcd_wrcmd>
    ldi     r24,0x00
 4f0:	80 e0       	ldi	r24, 0x00	; 0
    rcall   lcd_wrcmd
 4f2:	09 d0       	rcall	.+18     	; 0x506 <lcd_wrcmd>


    ; now 132*176*2 bytes are to be transmitted
    ldi     r31, 0xB5
 4f4:	f5 eb       	ldi	r31, 0xB5	; 181
    ldi     r30, 0x80
 4f6:	e0 e8       	ldi	r30, 0x80	; 128
    ldi     r24, 0xFF
 4f8:	8f ef       	ldi	r24, 0xFF	; 255

000004fa <LCD_CLEAR_1>:
LCD_CLEAR_1:
    rcall   lcd_wrdata
 4fa:	08 d0       	rcall	.+16     	; 0x50c <lcd_wrdata>
    sbiw    r30,1
 4fc:	31 97       	sbiw	r30, 0x01	; 1
    brne    LCD_CLEAR_1
 4fe:	e9 f7       	brne	.-6      	; 0x4fa <LCD_CLEAR_1>

    pop r31
 500:	ff 91       	pop	r31
    pop r30
 502:	ef 91       	pop	r30
    ret
 504:	08 95       	ret

00000506 <lcd_wrcmd>:
;************************************************
;send an LCD command
;        r24
    .global lcd_wrcmd
lcd_wrcmd:
    cbi     PORTB,LCD_CS    ;select Display
 506:	c3 98       	cbi	0x18, 3	; 24
    sbi     PORTB,LCD_RS    ; set RS line
 508:	c0 9a       	sbi	0x18, 0	; 24
    rjmp    SPI_SEND
 50a:	02 c0       	rjmp	.+4      	; 0x510 <SPI_SEND>

0000050c <lcd_wrdata>:
;send LCD data
;        r24
;void lcd_wrdata(u08 data)
    .global lcd_wrdata
lcd_wrdata:
    cbi     PORTB,LCD_CS    ;select Display
 50c:	c3 98       	cbi	0x18, 3	; 24
    cbi     PORTB,LCD_RS    ; clear RS line
 50e:	c0 98       	cbi	0x18, 0	; 24

00000510 <SPI_SEND>:

;************************************************
;using the SPI for communication

SPI_SEND:   
    sbi SPCR,SPE        ;enable SPI
 510:	6e 9a       	sbi	0x0d, 6	; 13
    out SPDR,r24        ;load byte in SPI data register
 512:	8f b9       	out	0x0f, r24	; 15

00000514 <SPI_SEND_0>:
SPI_SEND_0: 
    sbis    SPSR,SPIF
 514:	77 9b       	sbis	0x0e, 7	; 14
    rjmp    SPI_SEND_0      ;transmitt byte to LCD
 516:	fe cf       	rjmp	.-4      	; 0x514 <SPI_SEND_0>
    in  r0,SPDR
 518:	0f b0       	in	r0, 0x0f	; 15
    sbi PORTB,LCD_CS        ;deselect Display
 51a:	c3 9a       	sbi	0x18, 3	; 24
    ret
 51c:	08 95       	ret

0000051e <INIT1>:
 51e:	fd fd       	.word	0xfdfd	; ????
 520:	fd fd       	.word	0xfdfd	; ????
 522:	ef 00       	.word	0x00ef	; ????
 524:	ee 04       	cpc	r14, r14
 526:	1b 04       	cpc	r1, r11
 528:	fe fe       	.word	0xfefe	; ????
 52a:	fe fe       	.word	0xfefe	; ????
 52c:	ef 90       	pop	r14
 52e:	4a 04       	cpc	r4, r10
 530:	7f 3f       	cpi	r23, 0xFF	; 255
 532:	ee 04       	cpc	r14, r14
 534:	43 06       	cpc	r4, r19

00000536 <INIT2>:
 536:	ef 90       	pop	r14
 538:	09 83       	std	Y+1, r16	; 0x01
 53a:	08 00       	.word	0x0008	; ????
 53c:	0b af       	std	Y+59, r16	; 0x3b
 53e:	0a 00       	.word	0x000a	; ????
 540:	05 00       	.word	0x0005	; ????
 542:	06 00       	.word	0x0006	; ????
 544:	07 00       	.word	0x0007	; ????
 546:	ef 00       	.word	0x00ef	; ????
 548:	ee 0c       	add	r14, r14
 54a:	ef 90       	pop	r14
 54c:	00 80       	ld	r0, Z
 54e:	ef b0       	in	r14, 0x0f	; 15
 550:	49 02       	muls	r20, r25
 552:	ef 00       	.word	0x00ef	; ????
 554:	7f 01       	movw	r14, r30
 556:	e1 81       	ldd	r30, Z+1	; 0x01
 558:	e2 02       	muls	r30, r18
 55a:	e2 76       	andi	r30, 0x62	; 98
 55c:	e1 83       	std	Z+1, r30	; 0x01

0000055e <INIT3>:
 55e:	80 01       	movw	r16, r0

00000560 <_exit>:
 560:	f8 94       	cli

00000562 <__stop_program>:
 562:	ff cf       	rjmp	.-2      	; 0x562 <__stop_program>
